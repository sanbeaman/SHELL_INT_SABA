package com.sanbeaman.shell.widget{	import com.greensock.TimelineLite;	import com.greensock.TimelineMax;	import com.greensock.TweenLite;	import com.greensock.easing.Back;	import com.greensock.easing.Quint;	import com.greensock.events.LoaderEvent;	import com.greensock.events.TweenEvent;	import com.greensock.loading.ImageLoader;	import com.greensock.loading.LoaderMax;	import com.greensock.loading.XMLLoader;	import com.greensock.loading.core.LoaderCore;	import com.greensock.plugins.AutoAlphaPlugin;	import com.greensock.plugins.ColorTransformPlugin;	import com.greensock.plugins.GlowFilterPlugin;	import com.greensock.plugins.ShortRotationPlugin;	import com.greensock.plugins.TransformAroundCenterPlugin;	import com.greensock.plugins.TransformAroundPointPlugin;	import com.greensock.plugins.TweenPlugin;	import com.sanbeaman.shell.events.BMPScale9SimpleStateEvent;	import com.sanbeaman.shell.events.ShellEvent;	import com.sanbeaman.shell.events.WidgetBtnEvent;	import com.sanbeaman.shell.events.WidgetEvent;	import com.sanbeaman.shell.loading.display.ProgressCircleLite;	import com.sanbeaman.shell.loading.display.ProgressCircleMax;	import com.sanbeaman.shell.ui.BTN_BMPSimpleState;	import com.sanbeaman.shell.widget.CoverFlow_Image;	import com.sanbeaman.shell.widget.activity.Graphics_TimelineCoverFlow;		import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.GradientType;	import flash.display.Loader;	import flash.display.MovieClip;	import flash.display.Shape;	import flash.display.SpreadMethod;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.filters.BitmapFilter;	import flash.filters.BitmapFilterQuality;	import flash.filters.DropShadowFilter;	import flash.filters.GlowFilter;	import flash.geom.Matrix;
		public class Timeline_CoverFlow extends MovieClip	{				private var _slides:Array;		private var _shellDIR:String;				private var _IMG_WIDTH:Number; 		private var _IMG_HEIGHT:Number;				private static const _THUMB_GAP:Number =0;		private var _arrowLeft:BTN_BMPSimpleState;		private var _arrowRight:BTN_BMPSimpleState;				private var _imagesContainer:Sprite;		private var _arrowContainer:Sprite;				private var _xHolder:Number;		private var _slideIndex:int = 0;		private var _currentSlideIndex:int = 0;		private var _currentSlideID:String;//:int = 0;		private var _finalSlideIndex:int;				private var _startX:Number;		private var _widgetWidth:Number;		private var _widgetHeight:Number;								private var _normalIconPath:String ="icons/timelineArrow_normal1.png";		private var _hoverIconPath:String ="icons/timelineArrow_hover1.png";						private var _arrowNormal_bitmap:Bitmap;		private var _arrowHover_bitmap:Bitmap;		private var _tlloadercore:LoaderCore;				private var _progressCircle:ProgressCircleLite;		private var _preloadObject:Object = {thickness:74, radius:76, color:0x003366, trackColor:0xcccccc, trackAlpha:0.8, hideText:false, textColor:0xFFFFFF};						public function Timeline_CoverFlow()		{			super();			TweenPlugin.activate([TransformAroundCenterPlugin,TransformAroundPointPlugin,ShortRotationPlugin]);		}		/*		public function init(uinode:XML, shellDir:String, contentWidth:Number, contentHeight:Number):void		{			_slides = [];			_shellDIR = shellDir;// + "imgs/";								_imagesContainer = new Sprite();								this.addChildAt(_imagesContainer,0);								_IMG_WIDTH = uinode.@imgWidth;			_IMG_HEIGHT = uinode.@imgHeight;						_widgetWidth = contentWidth;			_widgetHeight = contentHeight;			_startX = _widgetWidth - int(_IMG_WIDTH/2);//SHELL_VARS.CONTENT_WIDTH - int(_IMG_WIDTH/2);			_imagesContainer.x= _startX;					//	var imageList:XMLList = uinode.*; //In the XML, we have <image /> nodes with all the info we need.			var imageList:XMLList = uinode.cfimgs.LoaderMax.*						//loop through each <image /> node and create a Slide object for each.			for each (var image:XML in imageList) {				trace('image.@name' + image.@name);				var icflow:Image_CoverFlow = new Image_CoverFlow();				icflow.init(image.@name,image.@name,LoaderMax.getContent(image.@name));				//var cflow:CoverFlow_Image = new CoverFlow_Image();				//cflow.init(image.@name,image.@name,LoaderMax.getLoader(image.@name));								_slides.push(icflow);			}						_finalSlideIndex = _slides.length - 1;							//	_progressCircle = new ProgressCircleLite(_preloadObject);						//this.addChild(_progressCircle);						//_tlloadercore = _setloadercore(_slides);						//now create a LoaderMax queue and populate it with all the thumbnail ImageLoaders as well as the very first full-size ImageLoader. We don't want to show anything until the thumbnails are done loading as well as the first full-size one. After that, we'll create another LoaderMax queue containing the rest of the full-size images that will load silently in the background.					//	var loadercore:LoaderCore = tlcf_LMax;			//_xmlProgress.addLoader(loadercore);		//	_progressCircle.addLoader(_tlloadercore);			//link the XMLLoader to the circular progress display			//var loadercore:LoaderCore = _templateLoader.startLoader(templateXML);		//	_xmlProgress.addLoader(loadercore);		}		*/		public function init(uinode:XML, shellDir:String, contentWidth:Number, contentHeight:Number):void		{			_slides = [];			_shellDIR = shellDir;// + "imgs/";						_IMG_WIDTH = uinode.@imgWidth;			_IMG_HEIGHT = uinode.@imgHeight;						_imagesContainer = new Sprite();		//	_imagesContainer.graphics.lineStyle(1,0x000000);		//	_imagesContainer.graphics.drawRect(0,0, _IMG_WIDTH* 10, _IMG_HEIGHT);						//	_arrowContainer = new Sprite();						this.addChildAt(_imagesContainer,0);			//this.addChild(_arrowContainer);								_widgetWidth = contentWidth;			_widgetHeight = contentHeight;			_startX = _widgetWidth - int(_IMG_WIDTH/2);//SHELL_VARS.CONTENT_WIDTH - int(_IMG_WIDTH/2);			_imagesContainer.x= _startX;						//	var imageList:XMLList = uinode.*; //In the XML, we have <image /> nodes with all the info we need.			var imageList:XMLList = uinode.cfimages.LoaderMax.*						//loop through each <image /> node and create a Slide object for each.			for each (var image:XML in imageList) {				trace('image.@name' + image.@name);				var icflow:Image_CoverFlow = new Image_CoverFlow();				var imgloader:ImageLoader = LoaderMax.getLoader(image.@name);				imgloader.load();			//	icflow.init(image.@name,image.@name,imgloader.content);			//icflow.init(image.@name,image.@name,LoaderMax.getContent(image.@name));				var cflow:CoverFlow_Image = new CoverFlow_Image();				//cflow.init(image.@name,image.@name,LoaderMax.getLoader(image.@name));				cflow.init(image.@name,image.@name,imgloader);				_slides.push(cflow);			}						_finalSlideIndex = _slides.length - 1;											_setupArrows();			var l:int = _slides.length;			var curX:Number =0;// _THUMB_GAP;			for (var i:int = 0; i < l; i++) {				var imgsprite:Sprite = _slides[i].image;			//	imgsprite.y = imgsprite.height * -1;				imgsprite.alpha = .7;				_imagesContainer.addChild(imgsprite);				_addShadowToSprite(imgsprite);				//TweenLite.to(thumbnail, 0, {colorTransform:{brightness:0.5}});				//_slides[i].addEventListener(Slide.CLICK_THUMBNAIL, _clickThumbnailHandler, false, 0, true);				imgsprite.x = curX;				//imgsprite.y = int(imgsprite.height  * -.5);				imgsprite.y = 0;				curX += _IMG_WIDTH + _THUMB_GAP;			}						_caroselStart();		}				private function _setloadercore(slidesarray:Array):LoaderCore		{			var tlcf_LMax:LoaderMax = new LoaderMax({onComplete:_mainLoadComplete});						//var arrowNormalpath:String = _shellDIR + _normalIconPath;			//var arrowHoverpath:String = _shellDIR + _hoverIconPath;						//tlcf_LMax.append( new ImageLoader(arrowNormalpath, {name:"arrow_normal", smoothing:true, estimatedBytes:1000}) );			//tlcf_LMax.append( new ImageLoader(arrowHoverpath, {name:"arrow_hover", smoothing:true, estimatedBytes:1000}) );			for (var i:int = 0; i < slidesarray.length; i++) {				tlcf_LMax.append( slidesarray[i].imageLoader );			}			//initialLoadQueue.append(_slides[0].imageLoader); //make sure the very first full-sized image is loaded initially too.			tlcf_LMax.load();						return tlcf_LMax;		}		private function  _setupLoadComplete(event:LoaderEvent):void {						_arrowNormal_bitmap = LoaderMax.getLoader("arrow_normal").rawContent;			_arrowHover_bitmap = LoaderMax.getLoader("arrow_hover").rawContent;			//now create a LoaderMax queue and populate it with all the thumbnail ImageLoaders as well as the very first full-size ImageLoader. We don't want to show anything until the thumbnails are done loading as well as the first full-size one. After that, we'll create another LoaderMax queue containing the rest of the full-size images that will load silently in the background.			var initialLoadQueue:LoaderMax = new LoaderMax({maxConnections:1,onComplete:_initialLoadComplete, onProgress:_progressHandler});			for (var i:int = 0; i < _slides.length; i++) {				initialLoadQueue.append( _slides[i].imageLoader );			}			//initialLoadQueue.append(_slides[0].imageLoader); //make sure the very first full-sized image is loaded initially too.			initialLoadQueue.load();		}						private function _progressHandler(event:LoaderEvent):void {			//_progressBar.progressBar_mc.scaleX = event.target.progress;			trace("progress="+ event.target.progress);		}		private function _mainLoadComplete(event:LoaderEvent):void {					_arrowNormal_bitmap = LoaderMax.getLoader("arrow_normal").rawContent;			_arrowHover_bitmap = LoaderMax.getLoader("arrow_hover").rawContent;						_setupArrows();			var l:int = _slides.length;			var curX:Number =0;// _THUMB_GAP;			for (var i:int = 0; i < l; i++) {				var imgsprite:Sprite = _slides[i].image;				imgsprite.alpha = .7;				_imagesContainer.addChild(imgsprite);				_addShadowToSprite(imgsprite);				//TweenLite.to(thumbnail, 0, {colorTransform:{brightness:0.5}});				//_slides[i].addEventListener(Slide.CLICK_THUMBNAIL, _clickThumbnailHandler, false, 0, true);				imgsprite.x = curX;				imgsprite.y = 0;				curX += _IMG_WIDTH + _THUMB_GAP;			}					_caroselStart();			//now start the slideshow					}		private function _initialLoadComplete(event:LoaderEvent):void {			//now that the initial load is complete, fade out the progressBar. autoAlpha will automatically set visible to false once alpha hits 0. 			//TweenLite.to(_progressBar, 0.5, {autoAlpha:0});			//fade in the thumbnails container			//TweenLite.to(_thumbnailsContainer, 1, {autoAlpha:1});			_arrowNormal_bitmap = LoaderMax.getLoader("arrow_normal").rawContent;			_arrowHover_bitmap = LoaderMax.getLoader("arrow_hover").rawContent;						_setupArrows();			//setup the ENTER_FRAME listeners that controls the thumbnail scrolling behavior at the bottom			//this.stage.addEventListener(Event.ENTER_FRAME, _enterFrameHandler, false, 0, true);						//now put all the remaining images into a LoaderMax queue that will load them one-at-a-time in the background in the proper order. This can greatly improve the user's experience compared to loading them on demand which forces the user to wait while the next image loads.			var l:int = _slides.length;			var curX:Number =0;// _THUMB_GAP;			for (var i:int = 0; i < l; i++) {				var imgsprite:Sprite = _slides[i].image;				imgsprite.alpha = .7;				_imagesContainer.addChild(imgsprite);				_addShadowToSprite(imgsprite);				//TweenLite.to(thumbnail, 0, {colorTransform:{brightness:0.5}});				//_slides[i].addEventListener(Slide.CLICK_THUMBNAIL, _clickThumbnailHandler, false, 0, true);				imgsprite.x = curX;				imgsprite.y = 0;				curX += _IMG_WIDTH + _THUMB_GAP;			}															_caroselStart();			//now start the slideshow					}		private function _caroselBack():void		{			//_slideIndex--;			_currentSlideIndex--;// = //_slideIndex;			_xHolder = _imagesContainer.x;			var nextX:Number = _xHolder + _IMG_WIDTH;			TweenLite.to(_imagesContainer, .5, {x:nextX,onComplete:_pauseCarosel});											}		private function _caroselForward():void		{			//_slideIndex++			_currentSlideIndex++;// = _slideIndex;			_xHolder = _imagesContainer.x;			var nextX:Number = _xHolder - _IMG_WIDTH;			TweenLite.to(_imagesContainer, .5, {x:nextX,onComplete:_pauseCarosel});											}		private function _caroselStart():void		{			trace('_caroselStart');			//_progressCircle.removeLoader(_tlloadercore);		//	this.removeChild(_progressCircle);			_xHolder = _imagesContainer.x;			var nextX:Number = _xHolder - _IMG_WIDTH;			TweenLite.to(_imagesContainer, .5, {x:nextX,onComplete:_pauseCarosel});								}		private function _pauseCarosel():void		{						//_currentSlideIndex = _slideIndex;			//_slideIndex++		//	trace('number of children in _imagesContainer= '+  _imagesContainer.numChildren);						_imagesContainer.addChild(_slides[_currentSlideIndex].image)			TweenLite.to(_slides[_currentSlideIndex].image, .8, {transformAroundCenter:{scale:1.8},alpha:1,ease:Back.easeOut});			//TweenLite.to(this.image, 0.3, {alpha:.5, scaleX:.5, scaleY:.5,ease:ExpoOut});			//TweenLite.to(_slides[currentSlideIndex].image,0.2,{		//	trace ('_pauseCarosel for _currentSlideIndex' + _currentSlideIndex);			//TweenLite.delayedCall(2, _startCarosel);									var wEvent:WidgetEvent = new WidgetEvent(WidgetEvent.TIMELINE_EVENT,"showSlideIndex",_currentSlideIndex);			this.dispatchEvent(wEvent);						_checkWidgetStatus(_currentSlideIndex);									//_activateArrows(_currentSlideIndex);								}				private function _checkWidgetStatus(sldIndex:int):void		{			if (sldIndex < 1 ) {			//	_arrowRight.visible = true;				//_arrowRight.alpha = 1;								_arrowRight.btnenabled = true;				if(_arrowRight.hasEventListener(MouseEvent.CLICK)){					//_arrowRight.removeEventListener(MouseEvent.CLICK, clickdownfunction);				} else {					_arrowRight.addEventListener(MouseEvent.CLICK,_showNextSlide,false,0,true);								}				_arrowLeft.btnenabled = false;				if (_arrowLeft.hasEventListener(MouseEvent.CLICK)){					_arrowLeft.removeEventListener(MouseEvent.CLICK, _showPreviousSlide);				}				//_arrowLeft.visible = true;			//	_arrowLeft.alpha = .5;											} else if (sldIndex >= _finalSlideIndex) {				_arrowLeft.btnenabled = true;				if(_arrowLeft.hasEventListener(MouseEvent.CLICK)){					//_arrowRight.removeEventListener(MouseEvent.CLICK, clickdownfunction);				} else {					_arrowLeft.addEventListener(MouseEvent.CLICK,_showPreviousSlide,false,0,true);				}				_arrowRight.btnenabled = false;				if (_arrowRight.hasEventListener(MouseEvent.CLICK)){					_arrowRight.removeEventListener(MouseEvent.CLICK, _showNextSlide);				}				_widgetComplete();			} else {				_quickArrowEnable(true);			}		}		private function _widgetComplete():void		{			var we:WidgetEvent = new WidgetEvent(WidgetEvent.TIMELINE_EVENT,"timelineComplete");			this.dispatchEvent(we);		}		private function _quickArrowEnable(btnenable:Boolean):void		{			_arrowLeft.btnenabled = btnenable;			_arrowRight.btnenabled = btnenable;			if (btnenable){				if(_arrowRight.hasEventListener(MouseEvent.CLICK)){					//already active				} else {					_arrowRight.addEventListener(MouseEvent.CLICK,_showNextSlide,false,0,true);				}				if(_arrowLeft.hasEventListener(MouseEvent.CLICK)){					//already active				} else {					_arrowLeft.addEventListener(MouseEvent.CLICK,_showPreviousSlide,false,0,true);				}			} else {				if (_arrowLeft.hasEventListener(MouseEvent.CLICK)){					_arrowLeft.removeEventListener(MouseEvent.CLICK, _showPreviousSlide);				}				if (_arrowRight.hasEventListener(MouseEvent.CLICK)){					_arrowRight.removeEventListener(MouseEvent.CLICK, _showNextSlide);				}			}								}		private function _activateArrows(cIndex:int):void		{			if (cIndex == 0) {				_arrowRight.visible = true;				_arrowRight.alpha = 1;				_arrowLeft.visible = false;				_arrowLeft.alpha = 0;							} else {				_arrowRight.visible = true;				_arrowRight.alpha = 1;				_arrowLeft.visible = true;				_arrowLeft.alpha =1 ;			}				}				private function _addShadowToSprite(spr:Sprite):void		{			var imgWidth:Number = Number( spr.width);			var imgHeight:Number = Number( spr.height);			var shadow:Sprite = new Sprite();			var ellip:Shape = new Shape();			var ellipWidth:Number=imgWidth;			var shadowWidth:Number = int(imgWidth /3) * 2;			var ellipHeight:Number= int(shadowWidth * .03);//8;						var colors:Array = [0x666666, 0xcccccc ];			var alphas:Array = [.4, .2];			var ratios:Array = [0,255];									var fillType:String = GradientType.RADIAL;			//var colors:Array = [0x000000, 0xcccccc ];			//var alphas:Array = [.5, .2];			//var ratios:Array = [0,255];			var mat:Matrix = new Matrix();									//x- and y- scaling of a radial gradient will automatically happen			//if you use a non-square 'gradientBox' for radial gradient, as in			//ellip below. The radial gradient will be vertically squeezed			//by the factor of 2 as ellipHeight is twice smaller than ellipWidth.			//In additon, the size of the gradientBox is smaller than the size of			//the ellipse, 'ellip'. The gradient will spread according to			//SpreadMethod.REFLECT. Note the translation parameters that move			//the center of the gradient to the center of 'ellip'.			mat.createGradientBox(ellipWidth,ellipHeight,_toRad(-90),0,0);//3*ellipWidth/8,3*ellipHeight/8);			ellip.graphics.lineStyle();			ellip.graphics.beginGradientFill(GradientType.RADIAL,colors,alphas,ratios,mat, 				SpreadMethod.PAD);			ellip.graphics.drawEllipse(0,0,ellipWidth,ellipHeight);			ellip.graphics.endFill();						shadow.addChild(ellip);			/*			var fillType:String = GradientType.RADIAL;			var colors:Array = [0xffffff, 0x000000];			var alphas:Array = [0, 1];			var ratios:Array = [0x00, 0xFF];			var matr:Matrix = new Matrix();			matr.createGradientBox(20, 20,Math.PI / 2 , 0, 0);			var spreadMethod:String = SpreadMethod.PAD;			//	this.graphics.beginGradientFill(fillType, colors, alphas, ratios, matr, spreadMethod);       			//	this.graphics.drawRect(0,0,100,100);						var shadow:Sprite = new Sprite();			shadow.graphics.beginGradientFill(fillType, colors, alphas, ratios, matr, spreadMethod);  			shadow.graphics.drawEllipse(0,0,244,6);			*/						var glowf:BitmapFilter = _getGLOWBitmapFilter();			shadow.filters = [glowf];						shadow.x = spr.x - int(imgWidth /2);			shadow.y =  int(imgHeight /2) + 20;			spr.addChild(shadow);								}		private function _addShadow():void		{			var imgWidth:Number = Number( _slides[_currentSlideIndex].image.width);			var imgHeight:Number = Number( _slides[_currentSlideIndex].image.height);			var shadow:Sprite = new Sprite();			var ellip:Shape = new Shape();			var ellipWidth:Number=imgWidth;			var ellipHeight:Number=8;			var fillType:String = GradientType.RADIAL;			var colors:Array = [0x000000, 0xcccccc ];			var alphas:Array = [.6, .2];			var ratios:Array = [0,255];			var mat:Matrix = new Matrix();									//x- and y- scaling of a radial gradient will automatically happen			//if you use a non-square 'gradientBox' for radial gradient, as in			//ellip below. The radial gradient will be vertically squeezed			//by the factor of 2 as ellipHeight is twice smaller than ellipWidth.			//In additon, the size of the gradientBox is smaller than the size of			//the ellipse, 'ellip'. The gradient will spread according to			//SpreadMethod.REFLECT. Note the translation parameters that move			//the center of the gradient to the center of 'ellip'.			mat.createGradientBox(ellipWidth,ellipHeight,_toRad(-90),0,0);//3*ellipWidth/8,3*ellipHeight/8);			ellip.graphics.lineStyle();			ellip.graphics.beginGradientFill(GradientType.RADIAL,colors,alphas,ratios,mat, 				SpreadMethod.PAD);			ellip.graphics.drawEllipse(0,0,ellipWidth,ellipHeight);			ellip.graphics.endFill();						shadow.addChild(ellip);			/*			var fillType:String = GradientType.RADIAL;			var colors:Array = [0xffffff, 0x000000];			var alphas:Array = [0, 1];			var ratios:Array = [0x00, 0xFF];			var matr:Matrix = new Matrix();			matr.createGradientBox(20, 20,Math.PI / 2 , 0, 0);			var spreadMethod:String = SpreadMethod.PAD;			//	this.graphics.beginGradientFill(fillType, colors, alphas, ratios, matr, spreadMethod);       			//	this.graphics.drawRect(0,0,100,100);						var shadow:Sprite = new Sprite();			shadow.graphics.beginGradientFill(fillType, colors, alphas, ratios, matr, spreadMethod);  			shadow.graphics.drawEllipse(0,0,244,6);			*/						var glowf:BitmapFilter = _getGLOWBitmapFilter();			shadow.filters = [glowf];						shadow.x = _slides[_currentSlideIndex].image.x - int(imgWidth /2);			shadow.y =  int(imgHeight /2) + 10;			_imagesContainer.addChild(shadow);								}				private function _toRad(a:Number):Number {			return a*Math.PI/180;		}				private function _getGLOWBitmapFilter():BitmapFilter {			var color:Number = 0x666666;			var alpha:Number = 0.6;			var blurX:Number = 60;			var blurY:Number = 10;			var strength:Number = 2;			var inner:Boolean = false;			var knockout:Boolean = false;			var quality:Number = BitmapFilterQuality.MEDIUM;					//	var quality:Number = BitmapFilterQuality.HIGH;						return new GlowFilter(color,				alpha,				blurX,				blurY,				strength,				quality,				inner,				knockout);		}		private function _showNextSlide(me:MouseEvent = null):void		{			_quickArrowEnable(false);			var we:WidgetEvent = new WidgetEvent(WidgetEvent.TIMELINE_EVENT,"clearSlideIndex",_currentSlideIndex);			this.dispatchEvent(we);						TweenLite.to(_slides[_currentSlideIndex].image, .4, {transformAroundCenter:{scale:1},alpha:.8, ease:Quint.easeOut, onComplete:_caroselForward});					}		private function _showPreviousSlide(me:MouseEvent = null):void		{			_quickArrowEnable(false);			var we:WidgetEvent = new WidgetEvent(WidgetEvent.TIMELINE_EVENT,"clearSlideIndex",_currentSlideIndex);			this.dispatchEvent(we);						TweenLite.to(_slides[_currentSlideIndex].image, .4, {transformAroundCenter:{scale:1},alpha:.8, ease:Quint.easeOut, onComplete:_caroselBack});					}		private function _dupBMP(original:Bitmap):Bitmap {			var bmp:Bitmap = new Bitmap(original.bitmapData.clone());			return bmp;		}		private function _quickCopyFlip(original:Bitmap, axis:String = "x"):Bitmap		{			var bmpcopy:Bitmap = new Bitmap(original.bitmapData.clone());						var flipped:BitmapData = new BitmapData(bmpcopy.width, bmpcopy.height, true, 0);			var matrix:Matrix			if(axis == "x"){				matrix = new Matrix( -1, 0, 0, 1, bmpcopy.width, 0);			} else {				matrix = new Matrix( 1, 0, 0, -1, 0, bmpcopy.height);			}			flipped.draw(bmpcopy, matrix, null, null, null, true);			var flippedbmp:Bitmap = new Bitmap(flipped);						return flippedbmp;		}		private function _setupArrows():void {						var arrowNormal_loader:ImageLoader = LoaderMax.getLoader("arrow_normal") as ImageLoader;			var arrowHover_loader:ImageLoader = LoaderMax.getLoader("arrow_hover") as ImageLoader;			trace("arrowNormal_loader=>"+ arrowNormal_loader.status);			trace("arrowHover_loader=>"+ arrowHover_loader.status);			arrowNormal_loader.load();			arrowHover_loader.load();			trace("arrowNormal_loader=>"+ arrowNormal_loader.status);			trace("arrowHover_loader=>"+ arrowHover_loader.status);			_arrowNormal_bitmap = arrowNormal_loader.rawContent as Bitmap;			_arrowHover_bitmap = arrowHover_loader.rawContent as Bitmap;									var arrowLeft_normal:Bitmap = _dupBMP(_arrowNormal_bitmap);			var arrowLeft_hover:Bitmap = _dupBMP(_arrowHover_bitmap);			var arrowLeft_down:Bitmap = _dupBMP(_arrowNormal_bitmap);						var arrowRight_normal:Bitmap = _quickCopyFlip(_arrowNormal_bitmap);			var arrowRight_hover:Bitmap =  _quickCopyFlip(_arrowHover_bitmap);			var arrowRight_down:Bitmap = _quickCopyFlip(_arrowNormal_bitmap);						_arrowLeft = new BTN_BMPSimpleState("left",arrowLeft_normal.bitmapData,arrowLeft_hover.bitmapData,arrowLeft_down.bitmapData);			_arrowRight = new BTN_BMPSimpleState("right",arrowRight_normal.bitmapData,arrowRight_hover.bitmapData,arrowRight_down.bitmapData);								_arrowLeft.alpha = _arrowRight.alpha = .5;			_arrowLeft.visible = _arrowRight.visible = true;				//	_arrowLeft.addEventListener(MouseEvent.ROLL_OVER, _rollOverArrowHandler, false, 0, true);		//	_arrowLeft.addEventListener(MouseEvent.ROLL_OUT, _rollOutArrowHandler, false, 0, true);		//	_arrowLeft.addEventListener(MouseEvent.CLICK, _showPreviousSlide, false, 0, true);		//	_arrowRight.addEventListener(MouseEvent.ROLL_OVER, _rollOverArrowHandler, false, 0, true);		//	_arrowRight.addEventListener(MouseEvent.ROLL_OUT, _rollOutArrowHandler, false, 0, true);		//	_arrowRight.addEventListener(MouseEvent.CLICK, _showNextSlide, false, 0, true);			_arrowLeft.x = 0;			_arrowRight.x = 755 - _arrowRight.width;						_arrowLeft.y = int(_arrowLeft.height / 2) * -1;			_arrowRight.y = _arrowLeft.y;		//	_arrowLeft.addEventListener(BMPScale9SimpleStateEvent.CLICKED,_showPreviousSlide,false,0,true);			//_arrowRight.addEventListener(BMPScale9SimpleStateEvent.CLICKED,_showNextSlide,false,0,true);			_arrowLeft.addEventListener(MouseEvent.CLICK, _showPreviousSlide,false,0,true);			_arrowRight.addEventListener(MouseEvent.CLICK,_showNextSlide,false,0,true);		//	_arrowLeft.addEventListener(WidgetBtnEvent.WIDGETBTN_CLICK,_showPreviousSlide,false,0,true);		//	_arrowRight.addEventListener(WidgetBtnEvent.WIDGETBTN_CLICK,_showNextSlide,false,0,true);						//_arrowContainer.addChild(_arrowRight);			//_arrowContainer.addChild(_arrowLeft);			this.addChild(_arrowRight);			this.addChild(_arrowLeft);					}								private function _imageFailHandler(event:LoaderEvent):void {			var slide:CoverFlow_Image;			var i:int = _slides.length;			while (--i > -1) {				slide = _slides[i];				if (event.target == slide.imageLoader) {					slide.dispose();					_slides.splice(i, 1);					//_setupThumbnails();					return;				}			}		}			}}